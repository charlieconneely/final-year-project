import React, { useState, useLayoutEffect, useEffect, useRef } from 'react'
import Peer from "peerjs";
import io from 'socket.io-client'
import uuid from 'react-uuid'
import { PureComponent } from 'react';

function VideoChat(props) {

  // So, I am going for a new approach here.
  // Instead of creating a room using a UUID url,
  // We're going to connect 2 users together by manually entering either;
  // 1.) A created UUID key
  // 2.) Autogenerated, server Peer ID's 
  // 3.) UUID Peer ID
  // 4.) Or by using a different Peer system instead of PeerJS

  //Defining socket.io
  const socketRef = useRef()
  socketRef.current = io.connect('/')

  // React.createRef() creates access DOM nodes or React elements
  // that are created within the render method. 
  const localVideo = React.createRef()
  const externalVideo = React.createRef()

  //Success constant for assigning video streams
  const success = (stream) => {
    window.localStream = stream
    localVideo.current.srcObject = stream;
    console.log("Permissions: 'Webcam' and 'Microphone' permissions approved.");
  }

  //Failure constant if video + audio are not provided by the user.
  const failure = (e) => {
    console.log("Permissions: Please enable 'Webcam' and 'Microphone' permissions.", e)
  }

  // Grabs user media from the browser using promises,
  // calling 'success' when video and audio returns 'true', 
  // and calls 'failure' if else.
  navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    })
    .then(success)
    .catch(failure)


  //A new PeerID is created everytime the script is called
  //this could cause potential spamming issues, maybe try find a way
  //to link the peerID to the peer's IP so if they get kicked, they cannot rejoin with a new PeerID.

  // console.log("Peer ID = " + peer.id)
  // const [otherID, setOtherID] = useState("")
  // const [myID, setMyID] = useState("")
  // const peer = new Peer(uuid());
  // const peer = new Peer(myID);
  // const conn = peer.connect(otherID);
  // conn.on('open', () => {
  //   conn.send('1.) ONE');
  // });

  // peer.on('connection', (conn) => {
  //   conn.on('data', (data) => {
  //     // Will print 'hi!'
  //     console.log(data);
  //   });
  //   conn.on('open', () => {
  //     conn.send('2.) TWO');
  //   });
  // });

  // navigator.mediaDevices.getUserMedia({video: true, audio: true}, (stream) => {
  //   localVideo.current.srcObject = stream;
  //   const call = peer.call(otherID, stream);
  //   call.on('stream', (remoteStream) => {
  //     externalVideo.current.srcObject = remoteStream;
  //     localVideo.current.srcObject = stream;
  //   });
  // }, (err) => {
  //   console.error('Failed to get local stream', err);
  // });

  // peer.on('call', (call) => {
  //   navigator.mediaDevices.getUserMedia({video: true, audio: true}, (stream) => {
  //     localVideo.current.srcObject = stream;
  //     call.answer(stream); // Answer the call with an A/V stream.
  //     call.on('stream', (remoteStream) => {
  //       externalVideo.current.srcObject = remoteStream;
  //       localVideo.current.srcObject = stream;
  //     });
  //   }, (err) => {
  //     console.error('Failed to get local stream', err);
  //   });
  // });

  return ( 
    <div>
      <h2> Video chat component. </h2> 

      <video ref={localVideo} autoPlay></video> 
      <video ref={externalVideo} autoPlay></video> 



    </div>
  );
}

export default VideoChat;