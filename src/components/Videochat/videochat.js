import React, { useRef } from 'react'
//import Peer from "peerjs";
import io from 'socket.io-client'
import uuid from 'react-uuid'

function VideoChat(props) {

  // So, I am going for a new approach here.
  // Instead of creating a room using a UUID url,
  // We're going to connect 2 users together by manually entering either;
  // 1.) A created UUID key
  // 2.) Autogenerated, server Peer ID's 
  // 3.) UUID Peer ID
  // 4.) Or by using a different Peer system instead of PeerJS

  //Defining socket.io
  //const socketRef = useRef()
  //socketRef.current = io.connect('/')

  // React.createRef() creates access DOM nodes or React elements
  // that are created within the render method;
  // (which is hidden when developing a functional hook instead of a react class component). 
  const localVideo = React.createRef()
  const externalVideo = React.createRef()

  // Transport connection to be established with the server at the temporary namespace;
  // '/webrtcPeer'.
  // The path '/webrtc' is the path captured by the serverside
  const socket = io(
    '/webrtcPeer',
    {
      path: '/webrtc',
      query: {}
    }
  )
  
  //CHECKING IF THE PAGE IS REFRESHING
  console.log(uuid())

  // Creates an RTCPeerConnection object with a list of TURN/STUN servers 
  const peerConnection_config = {
    'iceServers': [
      { url: 'stun:stun.l.google.com:19302' },
      { url: 'stun:stun1.l.google.com:19302' },
      { url: 'stun:stun2.l.google.com:19302' },
      { url: 'stun:stun3.l.google.com:19302' },
    ]
  }
  const peerConnection = new RTCPeerConnection(peerConnection_config)

  // Function that emits a socket event,
  // that takes in a socket identifier and payload,
  // and send the payload and socketID to the peer.
  const sendToPeer = (messageType, payload) => {
    socket.emit(messageType, {
      socketID: socket.id,
      payload
    })
  }

  // Event handler that specifies a function that happens 
  // whenever the local ICE agent needs to deliver a message to the other peer
  // through the signaling server.
  // It sends local candidate data to anyone who triggers this event.
  peerConnection.onicecandidate = (e) => {
    if (e.candidate){
      sendToPeer('candidate', e.candidate)
      console.log(JSON.stringify(e.candidate))
    }
  }

  peerConnection.oniceconnectionstatechange = (e) => {
    console.log(e)
  }

  // When a stream has been received, it is assigned to 
  // the externalVideo's 'React.createRef()' element.
  peerConnection.ontrack = function(event) {
    externalVideo.current.srcObject = event.streams[0];
  };

  // Create an offer. ("Just letting you know, these are my properties.")
  // If the offer creation is successful, it returns an 'SDP' and
  // the peerConnection's 'local description' is set to the 'SDP'.
  // ========================================================================
  // ('SDP' - Session Description Protocol) 
  // ('Local Description' - The properties of the local end of the connection.) 
  const createOffer = () => {
    console.log("Offer")
    peerConnection.createOffer({offerToReceiveVideo: 1}).then(sdp => {
      //Displays the SDP in JSON so we can copy it over to the other peer for testing.
      console.log(JSON.stringify(sdp))
      peerConnection.setLocalDescription(sdp)
    }, e => {})
  }

  // Set the 'remote description' to 'SDP' in json format
  // that is located in a textarea element with the ID = "jsonPasteBox" 
  // ========================================================================
  // ('Remote Description' - The properties of the remote end of the connection.) 
  const setRemoteDescription = () => {
    const desc = JSON.parse(document.getElementById("jsonPasteBox").value)
    peerConnection.setRemoteDescription(new RTCSessionDescription(desc))
    console.log("REMOTE DESCRIPTION SET!");
  }

  // Create an answer. ("Just letting you know, these are my properties.")
  // If the answer creation is successful, it returns an 'SDP' and
  // the peerConnection's 'local description' is set to the 'SDP'.
  // ========================================================================
  // ('SDP' - Session Description Protocol.) 
  // ('Local Description' - The properties of the local end of the connection.) 
  const createAnswer = () => {
    console.log("Answer")
    peerConnection.createAnswer({offerToReceiveVideo: 1}).then(sdp => {
      console.log(JSON.stringify(sdp))
      peerConnection.setLocalDescription(sdp)
    }, e => {})
  }

  // Adds an 'Ice Candidate' to your connection.
  // It parses JSON in the textarea element with the ID = "jsonPasteBox"
  // and creates a new connection to an 'Ice Candidate' (peer).
  // ========================================================================
  // ('ICE' - Internet Connectivity Establishment.)
  // ('Ice Candidate' - Describes the protocols and routing needed for WebRTC to be able to communicate with a remote device.) 
  const addCandidate = () => {
    const peer = JSON.parse(document.getElementById("jsonPasteBox").value)
    console.log("Adding peer = ", peer)
    peerConnection.addIceCandidate(new RTCIceCandidate(peer))
  }

  //Success constant for assigning video streams
  const success = (stream) => {
    window.localStream = stream
    localVideo.current.srcObject = stream;
    peerConnection.addStream(stream)
    console.log("Permissions: 'Webcam' and 'Microphone' permissions approved.");
  }

  //Failure constant if video + audio are not provided by the user.
  const failure = (e) => {
    console.log("Permissions: Please enable 'Webcam' and 'Microphone' permissions.")
  }

  // Grabs user media from the browser using promises,
  // calling 'success' when video and audio returns 'true', 
  // and calls 'failure' if else.
  navigator.mediaDevices.getUserMedia({
      video: true,
      audio: true
    })
    .then(success)
    .catch(failure)

  //A new PeerID is created everytime the script is called
  //this could cause potential spamming issues, maybe try find a way
  //to link the peerID to the peer's IP so if they get kicked, they cannot rejoin with a new PeerID.

  // console.log("Peer ID = " + peer.id)
  // const [myID, setMyID] = useState("")
  // const peer = new Peer(uuid());
  // const peer = new Peer(myID);
  // const conn = peer.connect(otherID);
  // conn.on('open', () => {
  //   conn.send('1.) ONE');
  // });

  // peer.on('connection', (conn) => {
  //   conn.on('data', (data) => {
  //     // Will print 'hi!'
  //     console.log(data);
  //   });
  //   conn.on('open', () => {
  //     conn.send('2.) TWO');
  //   });
  // });

  // navigator.mediaDevices.getUserMedia({video: true, audio: true}, (stream) => {
  //   localVideo.current.srcObject = stream;
  //   const call = peer.call(otherID, stream);
  //   call.on('stream', (remoteStream) => {
  //     externalVideo.current.srcObject = remoteStream;
  //     localVideo.current.srcObject = stream;
  //   });
  // }, (err) => {
  //   console.error('Failed to get local stream', err);
  // });

  // peer.on('call', (call) => {
  //   navigator.mediaDevices.getUserMedia({video: true, audio: true}, (stream) => {
  //     localVideo.current.srcObject = stream;
  //     call.answer(stream); // Answer the call with an A/V stream.
  //     call.on('stream', (remoteStream) => {
  //       externalVideo.current.srcObject = remoteStream;
  //       localVideo.current.srcObject = stream;
  //     });
  //   }, (err) => {
  //     console.error('Failed to get local stream', err);
  //   });
  // });

  return ( 
    <div>
      <h2> Video chat component. </h2> 

      <h1>My Video</h1>
      <video ref={localVideo} autoPlay></video> 
      <h1>Their Video</h1>
      <video ref={externalVideo} autoPlay></video> 
      
      <br></br><br></br><br></br>

      <button onClick={createOffer}>OFFER</button>
      <button onClick={createAnswer}>ANSWER</button>
      <div>
        <h2>Please paste Peer SDP or Candidate JSON below.</h2>
        <textarea id="jsonPasteBox" placeholder="Paste JSON here." input="text"/>
      </div>
     
      <button onClick={setRemoteDescription}>Set Remote Description</button>
      <button onClick={addCandidate}>Add Peer</button>

      <br></br><br></br><br></br>

    </div>
  );
}

export default VideoChat;